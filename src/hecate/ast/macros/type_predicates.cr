module Hecate::AST
  module Macros
    # Generate type predicate methods for all registered node types
    # This creates methods like `int_lit?`, `add?`, etc. for each node type
    # enabling idiomatic Crystal code like: `if node.binary_expr?`
    macro generate_type_predicates(*node_types)
      # Generate predicate methods on each specific node class
      {% for node_type in node_types %}
        class {{node_type}}
          # Predicate method returns true for this specific type
          def {{node_type.id.underscore}}? : Bool
            true
          end
        end
      {% end %}
      
      # Generate predicate methods on the base Node class that return false
      class ::Hecate::AST::Node
        {% for node_type in node_types %}
          # Default implementation returns false for all types
          def {{node_type.id.underscore}}? : Bool
            false
          end
        {% end %}
        
        # Return the node type as a symbol (for debugging/reflection)
        # This method is generated by the macro with mappings for all node types
        def node_type_symbol : Symbol
          class_name = self.class.name.split("::").last
          case class_name
          {% for node_type in node_types %}
            when {{node_type.id.stringify}} then :{{node_type.id.underscore}}
          {% end %}
          else
            :unknown
          end
        end
        
        # Check if this node is an expression (based on class name heuristics)
        def expression? : Bool
          class_name = self.class.name
          # Check if it inherits from an Expr class or has expression-like naming
          class_name.includes?("Expr") || 
            class_name.ends_with?("Lit") || 
            class_name.includes?("Op") ||
            class_name.includes?("Call")
        end
        
        # Check if this node is a statement (based on class name heuristics)  
        def statement? : Bool
          class_name = self.class.name
          # Check if it inherits from a Stmt class or has statement-like naming
          class_name.includes?("Stmt") ||
            class_name.includes?("Decl") ||
            class_name.includes?("Block") ||
            class_name.includes?("If") ||
            class_name.includes?("While") ||
            class_name.includes?("For") ||
            class_name.includes?("Return")
        end
        
        # Exhaustive pattern matching helpers
        # Returns all possible node type symbols for this AST definition
        def self.all_node_types : Array(Symbol)
          [
            {% for node_type in node_types %}
              :{{node_type.id.underscore}},
            {% end %}
          ] of Symbol
        end
        
        # Check if a given set of symbols covers all possible node types
        def self.exhaustive_match?(covered_types : Array(Symbol)) : Bool
          all_types = all_node_types
          covered_set = covered_types.to_set
          all_set = all_types.to_set
          covered_set == all_set
        end
        
        # Return missing node types from a pattern match
        def self.missing_from_match(covered_types : Array(Symbol)) : Array(Symbol)
          all_types = all_node_types
          covered_set = covered_types.to_set
          all_set = all_types.to_set
          (all_set - covered_set).to_a
        end
        
        # Validate that a case/when block covers all possible node types
        # Usage: Node.validate_exhaustive_match([:int_lit, :binary_op, :var_decl])
        def self.validate_exhaustive_match(covered_types : Array(Symbol))
          missing = missing_from_match(covered_types)
          unless missing.empty?
            raise "Non-exhaustive pattern match. Missing cases for: #{missing.join(", ")}"
          end
        end
      end
    end
    
    # Macro to extend finalize_ast with type predicate generation
    # This is called automatically when finalize_ast is used
    macro finalize_ast_with_predicates(*node_types)
      # First call the original visitor generation
      ::Hecate::AST.finalize_ast_visitors(\{{node_types.splat}})
      
      # Then generate type predicates
      ::Hecate::AST::Macros.generate_type_predicates(\{{node_types.splat}})
    end
  end
end